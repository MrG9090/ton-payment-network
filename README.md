# TON Payment Network

This is an implementation of a peer-to-peer payment network with multi-node routing based on the power of the TON Blockchain. More powerful than lightning!

## Техническое описание

Сеть состоит из одноранговых самостоятельных платежных узлов, которые устанавливают связи между собой с помощью деплоя смарт контракта в блокчейн и по сети, используя RLDP.

Платежная нода может быть как самостоятельным сервисом, если основная цель - заработок на обслуживании цепочек виртуальных каналов, так и частью других приложений (в виде библиотеки), если цель - предоставление или оплата услуг, например TON Storage и TON Proxy.

Пример взаимодействия: 
![Untitled Diagram drawio(3)](https://github.com/xssnick/ton-payment-network/assets/9332353/c127d64f-2f04-4e70-87e6-252d08d1ce47)


### Onchain каналы

Каждая нода обязательно отслеживает новые блоки в сети и вылавливает обновления, связанные с ее контрактами. Например, появление новых контрактов с ее ключом, когда кто-то хочет установить канал, и события, связанные с несогласованным закрытием.

Если нода хочет установить связь с другой нодой, она деплоит контракт платежного канала в блокчейн. Контракт содержит 2 публичных ключа: свой и соседский. Другая нода обнаруживает контракт в сети, проверяет параметры, и, если все в порядке, позволяет установить с собой сетевое соединение.

Для аутентификации по сети используются ключи каналов, специальное аутентификационное сообщение формируется из adnl адресов сторон и временной метки и подписывается ключем канала, ответное сообщение должно содержать adnl адреса помененые местами, временную метку и подпись другой стороны.

### Виртуальные каналы

Виртуальный канал может быть открыт из любой точки сети в любую другую, если существует цепочка связей между нодами, включая ончеин контракт и активное сетевое соединение. При этом для создания и закрытия виртуального канала не требуется никаких действий ончеин.

Виртуальный канал имеет такие характеристики, как: 
* Ключ
* Время жизни 
* Емкость
* Комиссия
  
Например, `A`, `B` и `C` имеют открытые каналы в блокчейне (`A->B`, `B->C`), при этом не существует ончеин канала `A->C`, но `A` может создать виртуальный канал до `C`, попросив `B` проксировать через его канал за небольшое вознаграждение. Таким образом цепочка будет `A->B->C`.

Глядя на пример выше, возникает вопрос - а что, если `B` возьмет монеты у `A` и не передаст их `C`? 
Ответ: `B` не сможет это сделать благодаря эллиптической криптографии и гибкому блокчейну TON.

Когда `A` просит `B` открыть виртуальный канал, он не передает деньги сразу, а лишь передает `B` подписанную гарантию того, что если `C` предоставит подтверждение получения перевода от `A`, то `B` переведет `C` запрошенную сумму. Затем `B` может запросить у `A` ту же сумму + комиссию, по тому же подтверждению, которое получил от `C`. И так далее по цепочке, если ее длина больше 3.

Каждое звено цепи открывает виртуальные каналы друг с другом, начиная от инициатора и заканчивая точкой назначения. Условия могут изменяться в зависимости от договоренностей между нодами, но ключ всегда остается единым, что позволяет закрыть канал всем участникам, передав подтверждение по цепочке. Условия каскадны от отправителя к получателю и включают друг друга. Например, если в цепочке из 4 звеньев 2 берут комиссию в размере 0.01 TON, то отправитель отправит 0.02 TON комиссии, половину из которой следующее звено передаст дальше. Время жизни канала всегда уменьшается от отправителя к получателю, чтобы предотвратить обман ноды, который заключается в том, чтобы закрыть канал в последний момент, чтобы нода не успела закрыть свою часть с следующим соседом.

В случае, если одна из нод по пути не согласится открыть канал со следующей, канал будет откачен по цепочке назад, и емкость канала будет разблокирована для отправителя. В худшем случае может произойти так, что одна из нод будет действовать не по правилам и не согласится откатывать или не будет отвечать на открытие канала. В таком случае емкость будет разблокирована после указанного в канале времени жизни.

#### Гарантии безопасности

Весь процесс происходит без взаимодействия с блокчейном, следовательно, комиссия сети не платится. К взаимодействию с блокчейном приходится прибегнуть только в случае разногласий, например, если сосед по цепочке ведет себя не по правилам, отказывается передать монеты в обмен на доказательство. Тогда можно просто отправить это доказательство в контракт, закрыв его, и получить свои деньги - все застраховано.

Виртуальные каналы реализованы с помощью условных платежей, условия которых описаны следующей логикой:
```c
int cond(slice input, int fee, int capacity, int deadline, int key) {
    slice sign = input~load_bits(512);
    throw_unless(24, check_data_signature(input, sign, key));
    throw_unless(25, deadline >= now());

    int amount = input~load_coins();
    throw_unless(26, amount <= capacity);

    return amount + fee;
}
```

Логика условных платежей выполняется оффчеин в случае согласованности сторон, а в случае разногласий - ончеин.

#### Анонимность виртуального канала

Все звенья цепи известны только создателю виртуального канала, так как он формирует цепочку. Остальные звенья цепи знают только тех, кто открыл канал с ними, и тех, с кем нужно открыть виртуальный канал им. При этом не получится напрямую идентифицировать, является ли отправитель или получатель конечным звеном или промежуточным.

Это достигается за счет того, что отправитель формирует цепочку в 'Garlic' виде, где задания упакованы и зашифрованы shared ключом и могут быть расшифрованы только тем, кому это задание предназначено. В добавок к реальным заданиям передаются несуществующие для массовки.

Задание состоит из описания того, что должна получить нода от предыдущего соседа, и что передать следующему. Соседи не смогут обмануть друг друга, так как ожидаемые значения описаны в задании, и канал просто отклонится при нарушении.

### Взаимодействия по сети в цепочке

Сетевое взаимодействие строится на двух базовых действиях - `ProposeAction` и `RequestAction`.

* `Propose` - предполагает передачу подписанного модифицированного стейта канала с описанием желаемого изменения, например, открыть виртуальный канал. Сосед может либо принять, либо отказаться. В случае отказа он обязан подтвердить свой отказ подписью. Каждое действие `Propose` транзакционно и должно выполниться полностью или откатиться на обоих сторонах. В случае сетевых ошибок действие повторяется, пока не будет либо принято, либо отказано с подписью. Все действия выполняются строго последовательнов рамках канала. 

* `Request` - запрашивает соседнюю ноду сделать `Propose`, например, закрыть виртуальный канал.

### Скорость, надежность и кроссплатформенность

Открытие виртуального канала, при всей сложности - очень быстрое. Обработка на действия на стороне ноды занимает примерно 3 миллисекунды на обычном рабочем компьютере. А это значит что сервер вполне может открывать и закрывать > 300 виртуальных каналов в секунду, без особого труда. Этот показатель может быть сильно увеличен в дальнейшем, при улучшенном разделении блокировок.

Все важные действия выполняются с помощью специальной очереди, запись в которую происходит транзакционно с другими действиями, и подтверждением коммита на диск (ACID). Текущая реализация базы данных построена поверх встроенной LevelDB. 

Реализация выполнена на чистом Golang, и код может быть скомпилирован под все платформы, включая мобильные.

### Управление нодой

При запуске указывается флаг `-name {seed}`, где `{seed}` это любое слово из которого сгенерируется приватный ключ и кошелек, адрес кошелька выведется в консоль, и его нужно пополнить тестовыми монетами перед дальнейшими действиями.

На данный момент нода в виде самостоятельного сервиса поддерживает несколько консольных команд:

* `list` - Отобразить список активных ончеин и виртуальных каналов.
* `deploy_out` - Задеплоить канал с нодой имеющей введенный далее ключ (след командой) и балансом.
* `deploy_in` - Запросить у ноды с введенным далее ключем задеплоить канал с указаным далее балансом.
* `open` - Открыть виртуальный канал с введенным далее ключем, используя введенный далее ончеин канал как тунель. Генерирует и возвращает приватный ключ для вирт канала.
* `send` - Отправить монеты используя самозакрывающийся, после инициализации цепочки, виртуальный канал. Параметры аналогичны `open`.
* `sign` - Принимает на вход приватный ключ виртуального канала и сумму, возвращает стейт в hex формате, который другая сторона может использовать для закрытия виртуального канала.
* `close` - Закрыть виртуальный канал, на вход просит стейт от sign. Закрывать должен получатель.
* `destroy` - Закрыть ончеин канал с указаным далее адресом, сначала пытаемся кооперативно, если не получается, самостоятельно.

Также имеется развернутая нода с которой можно взаимодействовать, ее ключ публичный ключ - `6504e4cffb6c13cabebbb6e33be9168a40900595ea1d88461733a9c8ae084232`

### Roadmap

* Открытие виртуального канала с кем то без кошелька в сети (для перевода ему коинов до деплоя контракта)
* Виртуальные каналы в виде MerkleProof, для поддержки практически безлимитного количества активных виртуальных каналов на ончеин канал.
* Обновление состояний через MerkleUpdate.
* Поддержка Postgres в качестве альтернативного хранилища данных.
* API и Webhook события