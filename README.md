# TON-Payment-Network

This is an implementation of a peer-to-peer payment network with multi-node routing based on the power of the TON Blockchain.

## Техническое описание

Сеть состоит из одноранговых самостоятельных платежных узлов, которые устанавливают связи между собой с помощью деплоя смарт контракта в блокчейн и по сети, используя RLDP.

Платежная нода может быть как самостоятельным сервисом, если основная цель - заработок на обслуживании цепочек виртуальных каналов, так и частью других приложений (в виде библиотеки), если цель - предоставление или оплата услуг, например TON Storage и TON Proxy.

Пример взаимодействия: 
![Untitled Diagram drawio(3)](https://github.com/xssnick/ton-payment-network/assets/9332353/c127d64f-2f04-4e70-87e6-252d08d1ce47)


### Onchain каналы

Каждая нода обязательно отслеживает новые блоки в сети и вылавливает обновления, связанные с ее контрактами. Например, появление новых контрактов с ее ключом, когда кто-то хочет установить канал, и события, связанные с несогласованным закрытием.

Если нода хочет установить связь с другой нодой, она деплоит контракт платежного канала в блокчейн. Контракт содержит 2 публичных ключа: свой и соседский. Другая нода обнаруживает контракт в сети, проверяет параметры, и, если все в порядке, позволяет установить с собой сетевое соединение.

Для аутентификации по сети используются ключи каналов, специальное аутентификационное сообщение формируется из adnl адресов сторон и временной метки и подписывается ключем канала, ответное сообщение должно содержать adnl адреса помененые местами, временную метку и подпись другой стороны.

### Виртуальные каналы

Виртуальный канал может быть открыт из любой точки сети в любую другую, если существует цепочка связей между нодами, включая ончеин контракт и активное сетевое соединение. При этом для создания и закрытия виртуального канала не требуется никаких действий ончеин.

Например, `A`, `B` и `C` имеют открытые каналы в блокчейне (`A->B`, `B->C`), при этом не существует ончеин канала `A->C`, но `A` может создать виртуальный канал до `C`, попросив `B` проксировать через его канал за небольшое вознаграждение. Таким образом цепочка будет `A->B->C`.

Глядя на пример выше, возникает вопрос - а что, если `B` возьмет монеты у `A` и не передаст их `C`? 
Ответ: `B` не сможет это сделать благодаря эллиптической криптографии и гибкому блокчейну TON.

Когда `A` просит `B` открыть виртуальный канал, он не передает деньги сразу, а лишь передает `B` подписанную гарантию того, что если `C` предоставит подтверждение получения перевода от `A`, то `B` переведет `C` запрошенную сумму. Затем `B` может запросить у `A` ту же сумму + комиссию, по тому же подтверждению, которое получил от `C`. И так далее по цепочке, если ее длина больше 3.

Весь процесс происходит без взаимодействия с блокчейном, следовательно, комиссия сети не взимается. К взаимодействию с блокчейном приходится прибегнуть только в случае разногласий, например, если сосед по цепочке ведет себя не по правилам, отказывается передать монеты в обмен на доказательство. Тогда можно просто отправить это доказательство в контракт и получить свои деньги - все застраховано.

#### Гарантии безопасности

Виртуальные каналы реализованы с помощью условных платежей, условия которых описаны следующей логикой:
```c
int cond(slice input, int fee, int capacity, int deadline, int key) {
    slice sign = input~load_bits(512);
    throw_unless(24, check_data_signature(input, sign, key));
    throw_unless(25, deadline >= now());

    int amount = input~load_coins();
    throw_unless(26, amount <= capacity);

    return amount + fee;
}
```

Логика условных платежей выполняется оффчеин в случае согласованности сторон, а в случае разногласий - ончеин.

### Взаимодействия по сети в цепочке

Сетевое взаимодействие строится на двух базовых действиях - `ProposeAction` и `RequestAction`.

* `Propose` - предполагает передачу подписанного модифицированного стейта канала с описанием желаемого изменения, например, открыть виртуальный канал. Сосед может либо принять, либо отказаться. В случае отказа он обязан подтвердить свой отказ подписью. Каждое действие `Propose` транзакционно и должно выполниться полностью или откатиться на обоих сторонах. В случае сетевых ошибок действие повторяется, пока не будет либо принято, либо отказано с подписью. Все действия выполняются строго последовательнов рамках канала. 

* `Request` - запрашивает соседнюю ноду сделать `Propose`, например, закрыть виртуальный канал.

### Управление нодой

При запуске указывается флаг `-name {seed}`, где `{seed}` это любое слово из которого сгенерируется приватный ключ и кошелек, адрес кошелька выведется в консоль, и его нужно пополнить тестовыми монетами перед дальнейшими действиями.

На данный момент нода в виде самостоятельного сервиса поддерживает несколько консольных команд:

* `list` - Отобразить список активных ончеин и виртуальных каналов.
* `deploy_out` - Задеплоить канал с нодой имеющей введенный далее ключ (след командой) и балансом.
* `deploy_in` - Запросить у ноды с введенным далее ключем задеплоить канал с указаным далее балансом.
* `open` - Открыть виртуальный канал с введенным далее ключем, используя введенный далее ончеин канал как тунель. Генерирует и возвращает приватный ключ для вирт канала.
* `sign` - Принимает на вход приватный ключ виртуального канала и сумму, возвращает стейт в hex формате, который другая сторона может использовать для закрытия виртуального канала.
* `close` - Закрыть виртуальный канал, на вход просит стейт от sign. Закрывать должен получатель.
* `destroy` - Закрыть ончеин канал с указаным далее адресом, сначала пытаемся кооперативно, если не получается, самостоятельно.

Также имеется развернутая нода с которой можно взаимодействовать, ее ключ публичный ключ - `6504e4cffb6c13cabebbb6e33be9168a40900595ea1d88461733a9c8ae084232`

### Roadmap

* Открытие виртуального канала с кем то без кошелька в сети (для перевода ему коинов до деплоя контракта)
* Виртуальные каналы в виде MerkleProof, для поддержки практически безлимитного количества активных виртуальных каналов на ончеин канал.
* Обновление состояний через MerkleUpdate.
* Поддержка Postgres в качестве альтернативного хранилища данных.
